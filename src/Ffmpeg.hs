{-# LANGUAGE OverloadedStrings #-}
module Ffmpeg ( startVideoSplit
              , stopVideoSplit
              , composeVideo
              , takeLastFrame
              , ProcessHandle
              , Jpeg
              , writeJpeg
              , jpegPayload
              ) where

import System.IO
import System.Process
import qualified Data.ByteString as BS
import qualified Data.ByteString.Lazy.Char8 as B
import System.IO.Temp (withSystemTempFile, emptySystemTempFile)
import System.FilePath.ByteString (RawFilePath)
import System.Exit
import Control.Exception (throwIO)
import Network.Curl.Aeson (Payload(..))

import Exceptions

newtype Jpeg = Jpeg BS.ByteString

-- |Store given JPEG to given file.
writeJpeg :: FilePath -> Jpeg -> IO ()
writeJpeg path (Jpeg bs) = BS.writeFile path bs

jpegPayload (Jpeg bs) = Payload "image/jpeg" $ B.fromStrict bs

-- |Takes last frame of the video. This iterates through the whole
-- video so it's useful only for videos which are already split to
-- segments. Returns ByteString or throws ViggerException.
takeLastFrame :: FilePath -> IO Jpeg
takeLastFrame infile = withSystemTempFile "vigger.jpg" $ \outfile h -> do
  p <- runFfmpeg Nothing [ "-loglevel", "warning"
                         , "-i", infile
                         , "-update", "1"
                         , "-q:v", "3"
                         , outfile
                         ]
  val <- waitForProcess p
  case val of
    ExitSuccess   -> Jpeg <$> BS.hGetContents h
    ExitFailure x -> throwIO $ ViggerEncodeFail x

-- |Concatenates video using FFmpeg concat demuxer. May throw
-- ViggerException in case FFmpeg returns non-zero return value.
composeVideo :: Foldable t => FilePath -> t RawFilePath -> IO ()
composeVideo outfile infiles = withSystemTempFile "vigger.txt" $ \path h -> do
  B.hPutStr h payload
  hClose h
  p <- runFfmpeg Nothing [ "-loglevel", "warning"
                         , "-f", "concat"
                         , "-safe", "0"
                         , "-i", path
                         , "-c", "copy"
                         , outfile
                         ]
  val <- waitForProcess p
  case val of
    ExitSuccess -> pure ()
    ExitFailure x -> throwIO $ ViggerEncodeFail x
  where
    header = "ffconcat version 1.0\n# Automatically generated by vigger"
    escape "" = error "Empty filename given"
    escape bs = B.intersperse '\\' bs
    addFile a b = a <> "\nfile \\" <> escape (B.fromStrict b)
    payload = foldl addFile header infiles <> "\n"

-- |Stop splitting the video
stopVideoSplit :: ProcessHandle -> IO ()
stopVideoSplit h = do
  terminateProcess h
  waitForProcess h
  pure ()

-- |Start splitting the video and output to given directory
startVideoSplit :: FilePath -> String -> IO ProcessHandle
startVideoSplit dir video = runFfmpeg (Just dir)
  [ "-rtsp_transport", "tcp"
  , "-loglevel", "warning"
  , "-i", video
  , "-f", "segment"
  , "-reset_timestamps", "1"
  , "-segment_time", "0"
  , "-c", "copy"
  , "tmp-%d.mp4"
  ]

-- |Run FFmpeg with given working directory and arguments. Makes sure
-- stdin is not read and always overwrite.
runFfmpeg :: Maybe FilePath -> [String] -> IO ProcessHandle
runFfmpeg cwd args = do
  (_, _, _, h) <- createProcess cp
  pure h
  where cp = (proc "ffmpeg" argsFull){ cwd = cwd
                                     , std_in = NoStream
                                     , close_fds = True
                                     }
        argsFull = "-y" : "-nostdin" : args
